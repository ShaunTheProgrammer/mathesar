/*
This script provides helper functions for dealing with record summaries and record summary
templates.
*/

CREATE OR REPLACE FUNCTION
__msar.pick_best_record_summary_column(
  tab_id oid
) RETURNS smallint AS $$/*
  Given a table OID, this function returns the best singular column to use for a record summary of
  the table. The ideal column is the first column that is a string type. If no string columns are
  found, the first column is returned.

  Args:
    tab_id: The OID of the table for which to find the best column.

  Return value:
    The attnum of the best column to use for generating record summaries.
*/
DECLARE
  first_text_column smallint;
  first_column smallint;
BEGIN
  SELECT attnum INTO first_text_column
  FROM pg_catalog.pg_attribute a
  JOIN pg_catalog.pg_type t ON t.oid = a.atttypid 
  WHERE
    attrelid = tab_id AND
    attnum > 0 AND
    attisdropped = FALSE AND
    t.typcategory = 'S'
  ORDER BY attnum
  LIMIT 1;

  IF first_text_column IS NOT NULL THEN
    RETURN first_text_column;
  END IF;

  SELECT attnum INTO first_column
  FROM pg_catalog.pg_attribute
  WHERE attrelid = tab_id AND attnum > 0 AND attisdropped = FALSE;

  RETURN first_column;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION
msar.auto_generate_record_summary_template(
  tab_id oid
) RETURNS jsonb AS $$/*
  Given a table OID, this function generates a record summary template for the table. The template
  is generated by picking the best column to use for the record summary and wrapping it in an array.

  Args:
    tab_id: The OID of the table for which to generate a record summary template.

  Return value:
    A JSON array that represents the record summary template as described in
      msar.build_record_summary_query_from_template. The array contains a single element which is an
      array of column attnums. The column attnum is the best column to use for the record summary.
*/
BEGIN
  RETURN jsonb_build_array(
    jsonb_build_array(
      __msar.pick_best_record_summary_column(tab_id)
    )
  );
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION
msar.build_record_summary_query_from_template(
  tab_id oid,
  template jsonb
) RETURNS text AS $$/*
  Given a table OID and a record summary template, this function returns a query that can be used to
  generate record summaries for the table.

  Args:
    tab_id: The OID of the table for which to generate a record summary query.
    template: A JSON array that represents the record summary template (described in detail below).
    
  Example template:

    [
      "#",
      [1],
      " - ",
      [2, 5],
      " - ",
      [2, 5, 10]
    ]

  A string entry in the template represents static text to be included in the record summary
  verbatim.

  An array entry in the template represents a reference to data. Each element in the array is a
  column attnum. The first column attnum refers to a column in the base table. If the array
  contains more than one column reference, it represents a chain of FK columns starting from
  the base table and ending with a non-FK column. This function follows the foreign keys to
  produce the joins. Multi-column FK constraints are not supported.
  
  Return value: a stringified query which produces a result set matching the structure described
    in the return value of msar.get_record_summaries_via_query.
*/
DECLARE
  base_alias CONSTANT text := 'base';
  expr_parts text[];
  expr text;
  base_tab_fqn text := __msar.get_relation_name(tab_id);
  base_pk_name text := msar.get_column_name(tab_id, msar.get_pk_column(tab_id));
  template_part jsonb;
  join_clauses text[] := ARRAY[]::text[];
  join_section text;
BEGIN
  IF base_tab_fqn IS NULL THEN
    -- TODO: the test above won't work because `get_relation_name` returns a stringified number if the table doesn't exist
    RAISE EXCEPTION 'Unable to find table with oid %.', tab_id;
  END IF;
  IF base_pk_name IS NULL THEN
    RAISE EXCEPTION 'Unable to find primary key column for table with oid %.', tab_id;
  END IF;
  IF jsonb_typeof(template) <> 'array' THEN
    RAISE EXCEPTION 'Record summary template must be a JSON array.';
  END IF;

  <<template_parts_loop>>
  FOR template_part IN SELECT jsonb_array_elements(template) LOOP
    DECLARE
      ref_chain smallint[] := __msar.extract_smallints(template_part);
      ref_chain_length integer := array_length(ref_chain, 1);
      fk_col_id smallint;
      contextual_tab_id oid := tab_id;
      prev_alias text := base_alias;
      ref_column_name text;
    BEGIN
      -- Column reference template parts
      IF ref_chain_length > 0 THEN
        -- Except for the final ref_chain element, process all array elements as attnums of FK
        -- columns.
        FOREACH fk_col_id IN ARRAY ref_chain[1:ref_chain_length-1] LOOP
          DECLARE
            fk_col_name text := msar.get_column_name(contextual_tab_id, fk_col_id);
            ref_tab_id oid;
            ref_col_id smallint;
            ref_tab_fqn text;
            ref_col_name text;
            alias text;
            join_clause text;
          BEGIN
            IF fk_col_name IS NULL THEN
              -- Silently ignore references to non-existing columns. This can happen if a column
              -- has been deleted.
              CONTINUE template_parts_loop;
            END IF;

            SELECT confrelid, confkey[1] INTO ref_tab_id, ref_col_id
            FROM pg_catalog.pg_constraint
            WHERE contype = 'f' AND conrelid = contextual_tab_id AND conkey = array[fk_col_id];

            IF ref_tab_id IS NULL THEN
              -- Silently ignore references to non-FK columns. This can happen if the constraint
              -- has been dropped.
              CONTINUE template_parts_loop;
            END IF;

            ref_tab_fqn := __msar.get_relation_name(ref_tab_id);
            ref_col_name := msar.get_column_name(ref_tab_id, ref_col_id);
            alias := concat(prev_alias, '_', fk_col_id);
            join_clause := concat(
              'LEFT JOIN ',  ref_tab_fqn, ' AS ', alias,
              ' ON ', alias, '.', ref_col_name, ' = ', prev_alias, '.', fk_col_name
            );

            IF NOT join_clauses @> ARRAY[join_clause] THEN
              join_clauses := array_append(join_clauses, join_clause);
            END IF;
            prev_alias := alias;
            contextual_tab_id := ref_tab_id;
          END;
        END LOOP;

        ref_column_name := msar.get_column_name(contextual_tab_id, ref_chain[ref_chain_length]);
        expr_parts := array_append(expr_parts, concat(prev_alias, '.', ref_column_name));

      -- String literal template parts
      ELSIF jsonb_typeof(template_part) = 'string' THEN
        expr_parts := array_append(expr_parts, quote_literal(template_part #>> '{}'));
      END IF;
    END;
  END LOOP;

  IF array_length(expr_parts, 1) = 0 THEN
    -- If the template didn't give us anything to render, then we show '?' as a fallback. This can
    -- happen if (e.g.) the template only contains a reference which is no longer valid due to a
    -- column being deleted.
    expr_parts := array_append(expr_parts, quote_literal('?'));
  END IF;

  join_section := CASE
    WHEN array_length(join_clauses, 1) = 0 THEN ''
    ELSE chr(10) || array_to_string(join_clauses, chr(10))
  END;

  expr := array_to_string(expr_parts, E'\n    || ');

  RETURN concat(
    'SELECT ', chr(10),
    '  ', base_alias, '.', base_pk_name, ' AS id, ', chr(10),
    '  ', expr, ' AS record_summary', chr(10),
    'FROM ', base_tab_fqn, ' AS ', base_alias,
    join_section
  );

  -- TODO:
  -- - Handle columns which can't be automatically cast to TEXT
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION
msar.get_record_summaries_via_query(
  query text,
  id_values anyarray
) RETURNS TABLE (
  id anyelement,
  record_summary text
) AS $$/*
  Given a query and an array of IDs, this function returns the record summaries for the IDs
  specified in the array.

  Args:
    query: A stringified query which returns a result set having a structure identical to the
      return value of this function (described below).
    id_values: An array of IDs for which to retrieve record summaries.

  Return value: A table with the following columns:
    id: The primary key column of the table. This is always named `id`, even if the PK within the
      table has a different name. It will be unique.
    record_summary: A string that represents the record summary.
*/
BEGIN
  CREATE TEMP TABLE ids ON COMMIT DROP AS SELECT DISTINCT unnest(id_values) AS id;
  RETURN QUERY EXECUTE concat('
    WITH q AS ( ', query, ' )
    SELECT q.id, q.record_summary
    FROM ids
    JOIN q ON q.id = ids.id
  ');
  DROP TABLE ids;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION
msar.get_record_summaries(
  tab_id oid,
  id_values anyarray,
  template jsonb
) RETURNS TABLE (
  id anyelement,
  record_summary text
) AS $$/*
  Given a table OID, an array of primary key values, and (optionally) a record summary template,
  this function returns a table with the record summaries for the IDs specified in the array.

  Args:
    tab_id: The OID of the table for which to retrieve record summaries.
    id_values: An array of IDs for which to retrieve record summaries.
    template: (optional) A JSON array that represents the record summary template. If it is
      NULL or 'null'::jsonb, then the template will be auto-generated. See
      msar.build_record_summary_query_from_template for a full description of the template
      structure.
*/
SELECT * FROM msar.get_record_summaries_via_query(
  msar.build_record_summary_query_from_template(
    tab_id,
    CASE
      WHEN template IS NULL OR jsonb_typeof(template) = 'null' THEN
        msar.auto_generate_record_summary_template(tab_id)
      ELSE template
    END 
  ),
  id_values
)
$$ LANGUAGE sql;


CREATE OR REPLACE FUNCTION
msar.get_record_summaries(
  tab_id oid,
  id_values anyarray
) RETURNS TABLE (
  id anyelement,
  record_summary text
) AS $$/*
  Given a table OID, an array of primary key values this function returns a table with the record
  summaries for the IDs specified in the array.

  Args:
    tab_id: The OID of the table for which to retrieve record summaries.
    id_values: An array of IDs for which to retrieve record summaries.
*/
SELECT * FROM msar.get_record_summaries(tab_id, id_values, NULL)
$$ LANGUAGE sql;
